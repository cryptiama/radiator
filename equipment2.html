<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blue Hex Honey Ball</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #1a1a2e; }
        #scene-container { width: 100vw; height: 100vh; display: block; }
        /* Simple instructions overlay */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.5);
            font-family: sans-serif;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
    
    <!-- LOAD THREE.JS AND GSAP FROM THE INTERNET -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>

    <div id="scene-container"></div>
    <div id="instructions">Click ball to pulse â€¢ Move mouse to parallax</div>

    <script>
    // --- PART 1: SHADER UTILS & NOISE ---
    const shaderUtils = {
      noise4: `
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      float mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      float permute(float x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
      float taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }
      vec4 grad4(float j, vec4 ip) {
        const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
        vec4 p,s;
        p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
        p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
        s = vec4(lessThan(p, vec4(0.0)));
        p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;
        return p;
      }
      #define F4 0.309016994374947451
      float snoise(vec4 v) {
        const vec4  C = vec4( 0.138196601125011, 0.276393202250021, 0.414589803375032, -0.447213595499958);
        vec4 i  = floor(v + dot(v, vec4(F4)) );
        vec4 x0 = v -   i + dot(i, C.xxxx);
        vec4 i0;
        vec3 isX = step( x0.yzw, x0.xxx );
        vec3 isYZ = step( x0.zww, x0.yyz );
        i0.x = isX.x + isX.y + isX.z;
        i0.yzw = 1.0 - isX;
        i0.y += isYZ.x + isYZ.y;
        i0.zw += 1.0 - isYZ.xy;
        i0.z += isYZ.z;
        i0.w += 1.0 - isYZ.z;
        vec4 i3 = clamp( i0, 0.0, 1.0 );
        vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
        vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );
        vec4 x1 = x0 - i1 + C.xxxx;
        vec4 x2 = x0 - i2 + C.yyyy;
        vec4 x3 = x0 - i3 + C.zzzz;
        vec4 x4 = x0 + C.wwww;
        i = mod289(i);
        float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
        vec4 j1 = permute( permute( permute( permute (
                   i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
                 + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
                 + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
                 + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));
        vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;
        vec4 p0 = grad4(j0,   ip);
        vec4 p1 = grad4(j1.x, ip);
        vec4 p2 = grad4(j1.y, ip);
        vec4 p3 = grad4(j1.z, ip);
        vec4 p4 = grad4(j1.w, ip);
        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;
        p4 *= taylorInvSqrt(dot(p4,p4));
        vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
        vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);
        m0 = m0 * m0;
        m1 = m1 * m1;
        return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))
                     + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;
        }
    `,
    };

    // --- PART 2: BUBBLE SHADER ---
    const bubbleShader = {
      vertexShader: `
    varying vec2 vUv; 
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vN;
    varying vec3 eyeVector;
    varying vec3 worldNormal;
    uniform float u_time;
    uniform float pi;
    uniform vec3 u_camPos;
    uniform float u_speed1;
    uniform float u_freq1;
    uniform float u_amp1;
    float tangentFactor = 0.005;
    ${shaderUtils.noise4}
    vec3 orthogonal(vec3 v) {
      return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
    }
    vec3 distorted(vec3 p) {
      vec3 outPoint = p;
      outPoint = p*(1.+snoise(vec4(p*u_freq1, u_time*0.0001*u_speed1))*0.05);
      return outPoint;
    }
    void main() {
      vUv = uv; 
      vNormal = normal;
      vPosition = position;
      vec3 dispPos = distorted(position);
      vec3 tangent1 = orthogonal(normal);
      vec3 tangent2 = normalize(cross(normal, tangent1));
      vec3 nearby1 = position + tangent1 * tangentFactor;
      vec3 nearby2 = position + tangent2 * tangentFactor;
      vec3 distorted1 = distorted(nearby1);
      vec3 distorted2 = distorted(nearby2);
      vNormal = normalize(cross(distorted1 - dispPos, distorted2 - dispPos));
      vec4 p = vec4( position, 1. );
      vec3 e = normalize( vec3( modelViewMatrix * p ) );
      vec3 n = normalize( normalMatrix * vNormal );
      vec3 r = reflect( e, n );
      float m = 2. * sqrt( pow( r.x, 2. ) + pow( r.y, 2. ) + pow( r.z + 1., 2. ) );
      vN = r.xy / m + .5;
      vec4 worldPosition = modelMatrix * vec4( position, 1.0);
      eyeVector = normalize(worldPosition.xyz - u_camPos);
      worldNormal = normalize( modelViewMatrix * vec4(vNormal, 0.0)).xyz;
      vec4 modelViewPosition = modelViewMatrix * vec4(dispPos, 1.0);
      gl_Position = projectionMatrix * modelViewPosition; 
    }
      `,
      fragmentShader: `
    uniform float pi;
    uniform sampler2D u_refrTex;
    uniform vec2 u_res;
    uniform float u_ior;
    uniform float u_blur;
    uniform vec3 u_refColor;
    varying vec3 vNormal;
    varying vec3 eyeVector;
    varying vec3 worldNormal;
    float fresnel(vec3 eyeVector, vec3 worldNormal) {
        return pow( 1.0 + dot( eyeVector, worldNormal), 3.0 );
    }
    vec4 blur(sampler2D inputSamp, vec2 uv){
      vec4 outputCol = texture2D(inputSamp, uv);;
      float Directions = 16.0; 
      float Quality = 3.0; 
      float Size = 50.0*u_blur; 
      vec2 Radius = Size/u_res;
      for( float d=0.0; d<(pi*2.); d+=(pi*2.)/Directions) {
        for(float i=1.0/Quality; i<=1.0; i+=1.0/Quality) {
            outputCol += texture( inputSamp, uv+vec2(cos(d),sin(d))*Radius*i);		
        }
      }
      return outputCol /= Quality * Directions - 15.0;
    }
    void main() {
      vec2 uv = gl_FragCoord.xy / u_res;
      vec3 normal = worldNormal;
      vec3 refracted = refract(eyeVector, normal, 1.0/1.093);
      uv += refracted.xy;
      vec4 refrBg = blur(u_refrTex, uv);
      vec4 outCol = mix(refrBg, vec4(u_refColor, 1.), fresnel(eyeVector, normal));
      gl_FragColor = vec4(outCol);
    }
      `,
    }

    // --- PART 3: MAIN BALL SHADER ---
    const ballshaders = {
      vertexShader: `
    varying vec2 vUv; 
    varying vec3 vNormal;
    varying vec3 vPosition;
    varying vec2 vN;
    varying vec3 eyeVector;
    varying vec3 worldNormal;
    uniform float u_time;
    uniform vec3 u_camPos;
    uniform float u_speed1;
    uniform float u_freq1;
    uniform float u_amp1;
    float tangentFactor = 0.005;
    ${shaderUtils.noise4}
    vec3 orthogonal(vec3 v) {
      return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
    }
    vec3 distorted(vec3 p) {
      vec3 outPoint = p;
      // Distortion amount
      outPoint = p*(1.+snoise(vec4(p*u_freq1, u_time*0.0001*u_speed1))*0.05*u_amp1);
      return outPoint;
    }
    void main() {
      vUv = uv; 
      vNormal = normal;
      vPosition = position;
      vec3 dispPos = distorted(position);
      vec3 tangent1 = orthogonal(normal);
      vec3 tangent2 = normalize(cross(normal, tangent1));
      vec3 nearby1 = position + tangent1 * tangentFactor;
      vec3 nearby2 = position + tangent2 * tangentFactor;
      vec3 distorted1 = distorted(nearby1);
      vec3 distorted2 = distorted(nearby2);
      vNormal = normalize(cross(distorted1 - dispPos, distorted2 - dispPos));
      vec4 p = vec4( position, 1. );
      vec3 e = normalize( vec3( modelViewMatrix * p ) );
      vec3 n = normalize( normalMatrix * vNormal );
      vec3 r = reflect( e, n );
      float m = 2. * sqrt( pow( r.x, 2. ) + pow( r.y, 2. ) + pow( r.z + 1., 2. ) );
      vN = r.xy / m + .5;
      vec4 worldPosition = modelMatrix * vec4( position, 1.0);
      eyeVector = normalize(worldPosition.xyz - u_camPos);
      worldNormal = normalize( modelViewMatrix * vec4(vNormal, 0.0)).xyz;
      vec4 modelViewPosition = modelViewMatrix * vec4(dispPos, 1.0);
      gl_Position = projectionMatrix * modelViewPosition; 
    }
      `,
      fragmentShader: `
      #include <packing>
      uniform sampler2D u_matCap;
      uniform float pi;
      uniform sampler2D u_curRefrTex;
      uniform sampler2D u_tarRefrTex;
      uniform float u_transFactor;
      uniform sampler2D u_bubblesFBO;
      uniform vec2 u_res;
      uniform float u_ior;
      uniform float u_blur;
      uniform float u_lightfac;
      uniform vec3 u_targColor;
      uniform vec3 u_refColor;
      varying vec2 vN;
      varying vec3 vNormal;
      varying vec3 eyeVector;
      varying vec3 worldNormal;
      
      float fresnel(vec3 eyeVector, vec3 worldNormal) {
        return pow( 1.0 + dot( eyeVector, worldNormal), 3.0 );
      }
      
      void main() {
        // 1. MATCAP (LIGHTING)
        vec4 matCapCol = texture2D(u_matCap, vN);
      
        // 2. REFRACTION CALCULATION
        vec2 uv = gl_FragCoord.xy / u_res;
        vec3 normal = worldNormal;
        // Adjust index of refraction slightly over time
        float ior = u_ior + (1.-cos(u_transFactor*pi*2.))*0.1;
        vec3 refracted = refract(eyeVector, normal, 1.0/ior);
        uv += refracted.xy;
      
        // 3. BACKGROUND / BUBBLES
        vec4 bubblesCol = texture2D(u_bubblesFBO, uv);
        
        // This makes the bubbles darker inside
        vec4 darkerBubbles = mix(bubblesCol, vec4(0., 0., 0., 1.), .2);
        
        // Get Background Texture
        vec4 curBgCol = texture2D(u_curRefrTex, uv);
        vec4 tarBgCol = texture2D(u_tarRefrTex, uv);
        vec4 transBgCol = mix(curBgCol, tarBgCol, u_transFactor);
        
        // Combine Background with Bubbles
        vec4 bubblesMixBgOut = mix(transBgCol, darkerBubbles, bubblesCol.a);
      
        // 4. COMBINE REFRACTION & MATCAP
        // Mix the background pattern with the matcap lighting
        // 0.4 adds some brightness to the MatCap
        vec4 matCapLayer = bubblesMixBgOut * (matCapCol + 0.2); 
        
        // 5. REFLECTION COLOR (THE BLUE TINT)
        vec4 outCol = mix(matCapLayer, vec4(u_refColor, 1.), fresnel(eyeVector, normal));
      
        // 6. LIGHTING PULSE
        outCol *= vec4(u_lightfac);

        gl_FragColor = outCol;
      }
        `,
    }

    function remap(value, low1, high1, low2, high2) {
      return low2 + (high2 - low2) * (value - low1) / (high1 - low1)
    }

    // --- PART 4: CLASSES ---

    // --- BUBBLES CLASS ---
    class BubblesFBOClass {
      constructor() {}
      init(THREE, scene, camera, params) {
        this.THREE = THREE
        this.orCamera = camera
        this.camera = camera.clone()
        this.camera.layers.set(1)
        this.scene = scene
        this.params = { bubbleCount: params.count, bubbleSpeed: params.speed }
        this.uniforms = {
          u_refrTex: { value: null },
          u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          u_time: { value: 0. },
          u_refColor: { value: new THREE.Color(0xFFFFFF) },
          u_speed1: { value: 4 },
          u_freq1: { value: 0.7 },
          u_amp1: { value: 0.41 },
          pi: { value: Math.PI },
          u_blur: { value: params.blur },
          u_ior: { value: 10 },
          u_camPos: { value: camera.position }
        }
        this.bubbleOr = new THREE.Mesh(new THREE.IcosahedronGeometry(.2, 2), new THREE.ShaderMaterial({
          vertexShader: bubbleShader.vertexShader,
          fragmentShader: bubbleShader.fragmentShader,
          uniforms: this.uniforms
        }))
        this.generateBubbles()
        const format = parseFloat(THREE.DepthFormat)
        const type = parseFloat(THREE.UnsignedShortType)
        this.FBO = new this.THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight)
        this.FBO.texture.minFilter = THREE.NearestFilter
        this.FBO.texture.magFilter = THREE.NearestFilter
        this.FBO.depthTexture = new THREE.DepthTexture()
        this.FBO.depthTexture.format = format
        this.FBO.depthTexture.type = type
      }
      generateBubbles() {
        let targetChild = null
        this.scene.traverse(child => { if (child.name == "bubbleGroup") targetChild = child })
        if (targetChild) this.scene.remove(targetChild)
        this.bubbles = new this.THREE.Group()
        this.bubbles.name = "bubbleGroup"
        this.bubbles.layers.set(1)
        this.scene.add(this.bubbles)
        for (let i = 0; i < this.params.bubbleCount; i++) {
          const cl = this.bubbleOr.clone()
          const x = remap(Math.random(), 0, 1, -5, 5)
          const z = remap(Math.random(), 0, 1, -10, 10)
          const y = remap(Math.random(), 0, 1, -5, 10)
          cl.layers.set(1)
          cl.position.set(x, y, z)
          cl.scale.multiplyScalar(remap(Math.random(), 0, 1, .01, 2))
          this.bubbles.add(cl)
        }
      }
      setRefrTex(texture) { this.uniforms.u_refrTex.value = texture }
      changeTexture(texture) { this.uniforms.u_refrTex.value = texture }
      setParams(params) {
        if (params.count) { this.params.bubbleCount = params.count; this.generateBubbles() }
        if (params.speed) this.params.bubbleSpeed = params.speed
      }
      update(renderer, dt) {
        let i = 0
        while (i < this.bubbles.children.length) {
          const cl = this.bubbles.children[i]
          cl.position.y -= dt * 0.001 * this.params.bubbleSpeed
          if (cl.position.y < -5) cl.position.y = remap(Math.random(), 0, 1, 7, 15)
          i++
        }
        this.camera.position.copy(this.orCamera.position)
        this.camera.rotation.copy(this.orCamera.rotation)
        renderer.setRenderTarget(this.FBO)
        renderer.clear()
        renderer.render(this.scene, this.camera)
        renderer.clearDepth()
        renderer.setRenderTarget(null)
      }
      windowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight
        this.camera.updateProjectionMatrix()
        this.FBO.setSize(window.innerWidth, window.innerHeight)
      }
      bind() {
        this.windowResize = this.windowResize.bind(this)
        this.setParams = this.setParams.bind(this)
        this.generateBubbles = this.generateBubbles.bind(this)
        this.uniforms.u_res.value.set(window.innerWidth, window.innerHeight)
      }
    }
    const BubblesFBO = new BubblesFBOClass()

    // --- HONEY BALL CLASS ---
    class HoneyBallClass {
      constructor() { this.bind() }
      init(THREE, scene, camera, params, matCapUrl) {
        this.texLoader = new THREE.TextureLoader()
        this.scene = scene
        this.params = params
        this.THREE = THREE
        this.camera = camera
        this.animTween = null
        this.animationParamFactors = { amplitude: 6, frequency: 0.01, light: 2.5 }

        this.uniforms = {
          u_bubblesFBO: { value: BubblesFBO.FBO.texture },
          u_bubblesDepth: { value: BubblesFBO.FBO.depthTexture },
          u_matCap: { value: this.texLoader.load(matCapUrl) }, 
          u_curRefrTex: { value: null },
          u_tarRefrTex: { value: null },
          u_transFactor: { value: null },
          u_targColor: { value: new THREE.Color(0x323232) },
          u_res: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
          u_time: { value: 0. },
          u_refColor: { value: new THREE.Color(params.reflectionColor) },
          u_speed1: { value: 9.18 },
          u_freq1: { value: 0.55 },
          u_amp1: { value: 2.4 },
          pi: { value: Math.PI },
          u_ior: { value: params.refractionIndex },
          u_blur: { value: params.blur },
          u_tintInt: { value: .05 },
          u_lightfac: { value: 1 },
          u_camPos: { value: camera.position },
        }

        this.shaderMat = new THREE.ShaderMaterial({
          uniforms: this.uniforms,
          vertexShader: ballshaders.vertexShader,
          fragmentShader: ballshaders.fragmentShader,
        })

        this.rotator = new THREE.Group()
        const geom = new THREE.IcosahedronGeometry(2.5, 30) // Increased segments for smoothness
        this.ballMesh = new THREE.Mesh(geom, this.shaderMat)
        this.ballMesh.name = "HoneyBall"
        this.rotator.add(this.ballMesh)
        this.scene.add(this.rotator)
      }

      setRefrTex(texture) {
        this.uniforms.u_curRefrTex.value = texture
        this.uniforms.u_tarRefrTex.value = texture
      }

      changeTexture(texture) {
        this.uniforms.u_curRefrTex.value = this.uniforms.u_tarRefrTex.value
        this.uniforms.u_tarRefrTex.value = texture
        this.uniforms.u_transFactor.value = 0
        gsap.to(this.uniforms.u_transFactor, { value: 1, duration: 1 })
      }

      pulse(clockWise) {
        this.pulseFactor = 0
        if (this.animTween) this.animTween.kill()
        this.animTween = gsap.to(this, {
          pulseFactor: 1,
          duration: this.params.animationParams.pulseAnim.duration,
          ease: "power4.inOut",
          yoyo: true,
          repeat: 1,
          onUpdate: () => {
            this.uniforms.u_freq1.value = 0.55 + this.pulseFactor * this.animationParamFactors.frequency
            this.uniforms.u_amp1.value = 3.0 + this.pulseFactor * this.animationParamFactors.amplitude 
            this.uniforms.u_lightfac.value = 1 + this.pulseFactor * this.animationParamFactors.light
          },
        })
        const rotDir = clockWise ? -1 : 1
        gsap.to(this.rotator.rotation, {
          y: this.rotator.rotation.y + rotDir * 2,
          duration: this.params.animationParams.rotationAnim.duration,
          ease: "power4.out"
        })
      }

      setParams(params) {
        if (params.refractionIndex) this.uniforms.u_ior.value = params.refractionIndex
        if (params.reflectionColor) this.uniforms.u_refColor.value = new this.THREE.Color(params.reflectionColor)
      }

      update(intersects, dt) {
        this.ballMesh.material.uniforms.u_time.value += dt
        this.ballMesh.material.uniforms.u_camPos.value = this.camera.position
        this.ballMesh.material.uniforms.u_bubblesDepth.value = BubblesFBO.FBO.depthTexture
      }

      windowResize(THREE) {
        this.ballMesh.material.uniforms.u_res.value = new THREE.Vector2(window.innerWidth, window.innerHeight)
      }

      bind() {
        this.init = this.init.bind(this)
        this.setParams = this.setParams.bind(this)
        this.windowResize = this.windowResize.bind(this)
      }
    }
    const HoneyBall = new HoneyBallClass()

    // --- CAMERA PARALLAX CLASS ---
    class CamParallaxClass {
      constructor() {
        this.bind()
        this.active = true
        this.mousePos = { x: 0, y: 0 }
        this.params = { intensity: 0.004, ease: 0.025 }
      }
      init(camera) {
        this.camera = camera
        this.initZ = this.camera.position.z
        window.addEventListener('mousemove', this.onMouseMove)
      }
      onMouseMove(e) {
        this.mousePos.x = (e.clientX - window.innerWidth / 2) * this.params.intensity
        this.mousePos.y = (e.clientY - window.innerHeight / 2) * this.params.intensity
      }
      update() {
        if (!this.active) return
        this.camera.position.x += (this.mousePos.x - this.camera.position.x) * this.params.ease
        this.camera.position.y += (this.mousePos.y - this.camera.position.y) * this.params.ease
        this.camera.position.z += (this.initZ - this.camera.position.z) * this.params.ease
        this.camera.lookAt(0, 0, 0)
      }
      bind() { this.onMouseMove = this.onMouseMove.bind(this) }
    }
    const CamParallax = new CamParallaxClass()

    // --- MAIN SCENE CLASS ---
    class MainThreeSceneClass {
      constructor() {
        this.bind()
        this.refrTextures = []
        this.params = {
          bubbles: { count: 40, speed: 0.9, blur: .1, refractionIndex: 1.093 },
          mainBall: {
            reflectionColor: 0x182457, // DEEP BLUE from your reference image
            blur: 0,
            refractionIndex: 1.25, // Higher index for more distortion of the hex grid
            animationParams: {
              rotationAnim: { duration: 0.8 },
              pulseAnim: { duration: 0.35 }
            }
          },
        }
        this.rafId = null
        this.then = Date.now()
      }

      init(container, matCapUrl) {
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
        this.renderer.setSize(window.innerWidth, window.innerHeight)
        this.renderer.autoClear = false
        this.container = container
        this.container.appendChild(this.renderer.domElement)

        this.scene = new THREE.Scene()
        // Dark blue fog to blend edges like the reference
        this.scene.fog = new THREE.FogExp2(0x182457, 0.02);

        this.camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 1000)
        this.camera.position.set(0, 0, 15)
        if(window.innerWidth < 768) this.camera.position.set(0, 0, 28)

        CamParallax.init(this.camera)
        BubblesFBO.init(THREE, this.scene, this.camera, this.params.bubbles)
        HoneyBall.init(THREE, this.scene, this.camera, this.params.mainBall, matCapUrl)

        this.raycaster = new THREE.Raycaster()
        this.pointer = new THREE.Vector2(-200, -200)
        this.intersects = []
      }

      start() {
        window.addEventListener("resize", this.resizeCanvas)
        window.addEventListener("mousemove", this.onMouseMove)
        this.container.style.display = 'block'
        this.update()
      }

      initTextures(urls) {
        this.texLoader = new THREE.TextureLoader()
        this.refrTextures = []
        
        // Load the texture
        const tex = this.texLoader.load(urls[0], (texture) => {
            // Set texture wrap/repeat to match the grid pattern
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            // Set the background of the scene to this texture
            this.scene.background = texture;
        });

        this.refrTextures.push(tex)
        HoneyBall.setRefrTex(tex)
        BubblesFBO.setRefrTex(tex)
      }

      pulse(clockWise) { HoneyBall.pulse(clockWise) }

      update() {
        this.rafId = requestAnimationFrame(this.update)
        this.dt = Date.now() - this.then
        this.raycaster.setFromCamera(this.pointer, this.camera)
        this.intersects = this.raycaster.intersectObjects(this.scene.children)
        this.renderer.clear()
        this.renderer.render(this.scene, this.camera)
        HoneyBall.update(this.intersects, this.dt)
        BubblesFBO.update(this.renderer, this.dt)
        CamParallax.update()
        this.then = Date.now()
      }

      onMouseMove(event) {
        this.pointer.x = (event.clientX / window.innerWidth) * 2 - 1
        this.pointer.y = - (event.clientY / window.innerHeight) * 2 + 1
      }

      resizeCanvas() {
        this.renderer.setSize(window.innerWidth, window.innerHeight)
        this.camera.aspect = window.innerWidth / window.innerHeight
        this.camera.updateProjectionMatrix()
        HoneyBall.windowResize(THREE)
        BubblesFBO.windowResize()
      }

      bind() {
        this.resizeCanvas = this.resizeCanvas.bind(this)
        this.update = this.update.bind(this)
        this.start = this.start.bind(this)
        this.onMouseMove = this.onMouseMove.bind(this)
        this.init = this.init.bind(this)
      }
    }

    const MainThreeScene = new MainThreeSceneClass()

    // --- PART 5: INIT WITH LINKS ---
    window.onload = function() {
        const container = document.getElementById('scene-container');
        
        // ------------------------------------------
        // REPLACE THESE LINKS WITH YOUR LOCAL FILES 
        // IF YOU HAVE THEM SAVED
        // Example: const matCapURL = "matcap.png";
        // ------------------------------------------
        
        // 1. LIGHTING SPHERE (MatCap)
        // I used a placeholder that matches your beige sphere
        const matCapURL = "https://raw.githubusercontent.com/nidorx/matcaps/master/1024/5C5C5C_C9C9C9_969696_A9A9A9.png";
        
        // 2. TEXTURE (Hex Grid)
        // I used a placeholder that matches your blue grid
        const textureURL = "https://img.freepik.com/free-vector/dark-hexagonal-background-with-gradient-color_79603-1409.jpg";

        // Initialize Scene
        MainThreeScene.init(container, matCapURL);
        
        // Load Texture
        MainThreeScene.initTextures([textureURL]);
        
        // Start Loop
        MainThreeScene.start();
        
        window.addEventListener('click', () => { MainThreeScene.pulse(true); });
    };

    </script>
</body>
</html>